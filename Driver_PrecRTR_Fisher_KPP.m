%==========================================================================
% Driver for using Preconditioned Riemannian Trust Region on the manifold
% of fixed-rank matrices.
% Script for Fisher-KPP equation.
% Created:     2023.04.01
% Last change: 2023.04.13

%   Apr 1, 2023:
%       Created by copying 'Driver_PrecRTR_Fisher_KPP.m'.
%==========================================================================
close all; clear; clc;

options_plot;

% Run startup_PrecRTR before.

%--------------------------------------------------------------------------
% Data
%--------------------------------------------------------------------------
pars.problem_type = 'FKPP';

% Preconditiong: 0 for No, 1 for Yes.
pars.precon = 1;

options_lrie.verbosity = 1;
options_lrie.plot = true;
%--------------------------------------------------------------------------
% Low rank:
pars.K = 15;
%--------------------------------------------------------------------------
% Parameters for time evolution:
t0 = 0;
T = 1;   % final time
Nt = 101;   % points in time

% Time step for numerical integration:
pars.dt = (T - t0)/(Nt-1);
%--------------------------------------------------------------------------
% Manifold parameters
% Retraction type: 'metric', 'metric_explicit_inverse', 'ortho_ao', 'ortho_zhang'.
pars.retr_type = 'ortho_ao';

% Tolerance for rank truncation:
% tol_rank = 1e-11;
%--------------------------------------------------------------------------
% Parameters for trustregions (Manopt)
options_tr.maxiter = 100;
options_tr.minstepsize = 1e-12;
options_tr.tolgradnorm = 1e-10;
% options_tr.Delta_bar = 1;     % MS, 15.01.2021: It is better to comment
% %                               out this line and let manopt take care of
% %                               the Delta_bar automatically.
options_tr.verbosity = 1;
%--------------------------------------------------------------------------
% Spatial discretization:
% Interval boundaries:
wL = 0;
wR = 40;

% Spatial discretization:
Nx = 100;   % number of spatial grid points

x = linspace( wL, wR, Nx)';

% Colors in the yellow-orange palette
rnd_color_yellow_orange = [ ones(Nx,1), rand(Nx,1), 0.259*ones(Nx,1) ];

% Mesh size
hx = (wR-wL)/(Nx-1);

%--------------------------------------------------------------------------
% Save in the pars structure
pars.hx = hx;
pars.Nx = Nx;
%--------------------------------------------------------------------------
fprintf('+--------------------------------------------------------------+\n');
fprintf(['| Problem type: ', pars.problem_type, '                                           |\n'])
% fprintf(['| Finest level: ', num2str(pars.lev_finest), ...
%     '  (points: ', num2str(Nx), 'x', num2str(Nx), ')                           |\n'])
% fprintf(['| Low rank: ', num2str(pars.K), '                                                  |\n'])
if pars.precon==0
    fprintf('| WITHOUT PRECONDITIONER                                       |\n')
elseif pars.precon==1
    fprintf('| WITH PRECONDITIONER                                          |\n')
end
fprintf('+--------------------------------------------------------------+\n');
fprintf('|                         Precompute A                         |\n');
fprintf('+--------------------------------------------------------------+\n');
%--------------------------------------------------------------------------
% Create matrix A in sparse format
% The discretized Laplacian with homogeneous Neumann boundary conditions:
A = spdiags( ones(Nx,1) * [1 -2 1], -1:1, Nx, Nx );
A(end,end-1) = 2;
A(1,2) = 2;
pars.A = (1/hx^2) * A;
%--------------------------------------------------------------------------

% Load the IC generated by 'Driver_FKPP_ref_several_realizations' so that
% we are SURE that we are using the same initial condition.
% load("FKPP_W_ref_hist_Nx_100_K_dt0.125.mat")
load("FKPP_W_ref_hist_Nx_100_K_dt0.1.mat")

W_0 = W_ref_hist(:,:,1);

pars.Romega = spdiags(r_omega_array', 0, Nx, Nx);

hr = pars.dt * pars.Romega;
one_m_hr = speye(pars.Nx) - hr;

[ U, S, V ] = svd( W_0 );

% boolean_vect = diag(S) > tol_rank;

% Define the new rank:
% pars.K = nnz(boolean_vect);

% Truncate
W.U = U(:,1:pars.K);
W.S = S(1:pars.K,1:pars.K);
W.V = V(:,1:pars.K);
%--------------------------------------------------------------------------

% Pick the manifold of matrices of size n_h x n_h of fixed rank k.
problem.M = fixedrankembeddedfactory( Nx, Nx, pars.K, pars.retr_type );
problem.cost = @(X) cost_FKPP_f_from_struct( X, W, pars );
problem.egrad = @(X) egrad_FKPP_f_from_struct( X, W, pars );
% problem.ehess = @(X,H) ehess_FKPP_f_from_struct( X, H, pars );
warning('off', 'manopt:getHessian:approx')
%--------------------------------------------------------------------------

fprintf('+--------------------------------------------------------------+\n');
fprintf('|       Start time integration of Fisher-KPP equation...       |\n');
fprintf('+--------------------------------------------------------------+\n');

% Initialization of t_hist_lra, rank_W_hist_lra, and W_hist_lra:
t_hist_lra = zeros( 1, Nt );
rank_W_hist_lra = zeros( 1, Nt );
W_hist_lra = struct( 'U', {}, 'S', {}, 'V', {} );

time_iter = 1;
current_t = (time_iter-1) * pars.dt + t0;
t_hist_lra(1) = current_t;
W_hist_lra(1).U = W.U;
W_hist_lra(1).S = W.S;
W_hist_lra(1).V = W.V;
rank_W_hist_lra(1) = pars.K;

if options_lrie.verbosity >= 1
    fprintf('Rank of the initial condition: %d \n', pars.K );
end

for time_iter=2:Nt

    current_t = (time_iter-1) * pars.dt + t0;

    % Define the new cost function and gradient:
    problem.M = fixedrankembeddedfactory( Nx, Nx, pars.K, pars.retr_type );
    problem.cost = @(X) cost_FKPP_f_from_struct( X, W, pars );
    problem.egrad = @(X) egrad_FKPP_f_from_struct( X, W, pars );
%     problem.ehess = @(X,H) ehess_FKPP_f_from_struct( X, H, pars );

    % MS, added 2023.04.18. Define a preconditioner for the Hessian.
    if pars.precon==1
        problem.precon = @(X,H) getXi_FKPP_2( X, H, pars );
    end
    
%     %----------------------------------------------------------------------
%     % Check gradient and Hessian:
%     fprintf('+--------------------------------------------------------------+\n');
%     fprintf('|                         Check gradient                       |\n');
%     fprintf('+--------------------------------------------------------------+\n');
%     checkgradient(problem);
%     drawnow;
%     pause(.5)

%     fprintf('+--------------------------------------------------------------+\n');
%     fprintf('|                          Check Hessian                       |\n');
%     fprintf('+--------------------------------------------------------------+\n');
%     checkhessian(problem);
%     drawnow;
%     pause(.5)
%     %----------------------------------------------------------------------
%     % return;

    if options_tr.verbosity > 0
        fprintf('+--------------------------------------------------------------+\n');
        fprintf('|               Start Riemannian Trust Regions...              |\n');
        fprintf('+--------------------------------------------------------------+\n');
    end

    if options_lrie.verbosity >= 1
        fprintf('%d  \t %.3f \n', time_iter, current_t);
    end

    % Solve the problem with Riemannian Trust Regions
    [ W, ~, info_tr, ~ ] = trustregions( problem, W, options_tr );

    % Store history of t and W for later postprocessing:
    t_hist_lra(time_iter) = current_t;
    W_hist_lra(time_iter).U = W.U;
    W_hist_lra(time_iter).S = W.S;
    W_hist_lra(time_iter).V = W.V;

    %----------------------------------------------------------------------
%     % Rank adaption:
%     boolean_vect = diag(W.S) > tol_rank;
% 
%     % Define the new rank:
%     pars.K = nnz(boolean_vect);
% 
%     % Truncate
%     W.U = W.U(:,1:pars.K);
%     W.S = W.S(1:pars.K,1:pars.K);
%     W.V = W.V(:,1:pars.K);
% 
%     fprintf('\n   Rank: %.d     Last singular value: %.5e \n\n', pars.K, W.S(end,end));

    %----------------------------------------------------------------------

    rank_W_hist_lra(time_iter) = pars.K;

    % time_vect(irun) = toc;
    tr_gradnorm = [info_tr.gradnorm];
    num_inner_array = [info_tr.numinner];
    ntot_iter = length(tr_gradnorm) - 1;  % do not count the "0th" iteration
    % fprintf('Total time: %.2f s.\n', time_vect(irun) );

    if options_lrie.verbosity >= 2
        fprintf('Last grad. norm: %.4e.\n', tr_gradnorm(end) );
        fprintf('Residual: %.4e (norm of the Euclidean gradient).\n', norm_struct( problem.egrad( W ) ) );
        % CFR norm_Gh = norm_struct( getTruncationStruct( problem.egrad( Wh ), pars.K ) )
        % end

        fprintf('****************************************************************\n');
        fprintf('Number of outer iterations: %.2d\n', ntot_iter );
        fprintf('Sum number of inner iters:  %.2d\n', sum(num_inner_array) );
        fprintf('Max number of inner iters:  %.2d\n', max(num_inner_array) );
        fprintf('****************************************************************\n');
    end

    if options_lrie.plot
        % Form the full-rank matrix only for plotting purposes:
        W_mat = W.U * W.S * W.V';

        % Plot numerical solution at current time:
        plot( x, W_mat, "LineWidth", 1 )
        % Random colors in the yellow-orange palette:
        colororder( rnd_color_yellow_orange )
%         title(['Low-rank Implicit Euler, iter ',num2str(iter),', time = ', num2str(current_t)])
        xlabel('$ x $')
        ylabel('$ W $, low rank')
        xlim( [ wL 25 ] )
        ylim( [ -0.02 1.02 ] )
        title(['Low-rank+IE, iter ',num2str(time_iter),', time = ', num2str(current_t)])
        drawnow;
    end

end

%&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
%--------------------------------------------------------------------------
% SAVE DATA TO MAT-FILE
%--------------------------------------------------------------------------
fprintf('+--------------------------------------------------------------+\n');
fprintf('|                           Save data                          |\n');
fprintf('+--------------------------------------------------------------+\n');

fileName_mfile = [ 'mdatafiles/', pars.problem_type, '_Prec', num2str(pars.precon), ...
    '_W_hist_lra_Nx_', num2str(Nx), '_K', num2str(pars.K) '_dt', ...
    num2str(pars.dt), '.mat'];

% Save all the three factors U, S, V separately:
save( fileName_mfile, 't_hist_lra', 'W_hist_lra', 'rank_W_hist_lra' );
fprintf('Saved data to file %s.\n', fileName_mfile);
%--------------------------------------------------------------------------